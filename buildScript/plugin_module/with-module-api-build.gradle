ext {
    includeWithApi = {String moduleName ->
        //先正常加载这个模块
        include(moduleName)

        //找到这个模块的路径
        String originDir = project(moduleName).projectDir
        //这个是新的路径
        String targetDir = "${originDir}-api"
        //新模块的路径
        def sdkName = "${project(moduleName).name}-api"
        //新模块名字
        String apiName = "${moduleName.substring(1, moduleName.length())}-api"

        //这个是公共模块的位置，我预先放了一个 ApiBuildGralde.gradle 文件进去
        String apiGradle = "${rootProject.projectDir}/buildScript/"

        // 每次编译删除之前的文件
        deleteDir(targetDir)

        //复制.api文件到新的路径
        copy() {
            from originDir
            into targetDir
            exclude '**/build/'
            exclude '**/res/'
            include '**/*.api'
        }

        //直接复制公共模块的AndroidManifest文件到新的路径，作为该模块的文件
        copy() {
            from "${apiGradle}/template/AndroidManifest.xml"
            into "${targetDir}/src/main/"
        }

        String originManifestPath = "${originDir}/src/main/AndroidManifest.xml"

        def xml = new XmlParser().parse(originManifestPath)

        // 访问AndroidManifest文件中manifest节点的package属性
        def packageName = xml.attribute("package")

        //修改AndroidManifest文件包路径
        fileReader("${targetDir}/src/main/AndroidManifest.xml", "TEMPLATE_PACKAGE_NAME","${packageName}")

        //复制 gradle文件到新的路径，作为该模块的gradle
        copy() {
            from "${apiGradle}/template/ApiBuildGralde.gradle"
            into "${targetDir}/"
        }

        //删除空文件夹
        deleteEmptyDir(new File(targetDir))

        //重命名一下gradle
        def build = new File(targetDir + "/ApiBuildGralde.gradle")
        if (build.exists()) {
            build.renameTo(new File(targetDir + "/build.gradle"))
        }

        // 重命名.api文件，生成正常的.java文件
        renameApiFiles(targetDir, '.api', '.java')

        //正常加载新的模块
        include ":$sdkName"

    }

    // Return the packageName for the given buildVariant
    getPackageName = {variant ->
        def suffix = variant.buildType.packageNameSuffix
        def packageName = variant.productFlavors.get(0).packageName
        if (suffix != null && !suffix.isEmpty() && suffix != "null") {
            packageName += suffix
        }
        return packageName
    }


    /**
     * 替换AndroidManifest里面的字段
     */
    fileReader = {String path,String name,String sdkName ->
        def readerString = ""
        def hasReplace = false

        file(path).withReader('UTF-8') { reader ->
            reader.eachLine {
                if (it.find(name)) {
                    it = it.replace(name, sdkName)
                    hasReplace = true
                }
                readerString <<= it
                readerString << '\n'
            }

            if (hasReplace) {
                file(path).withWriter('UTF-8') {
                    within ->
                        within.append(readerString)
                }
            }
            return readerString
        }
    }


    deleteEmptyDir = { File dir ->
        if (dir.isDirectory()) {
            File[] fs = dir.listFiles();
            if (fs != null && fs.length > 0) {
                for (int i = 0; i < fs.length; i++) {
                    File tmpFile = fs[i];
                    if (tmpFile.isDirectory()) {
                        deleteEmptyDir(tmpFile);
                    }
                    if (tmpFile.isDirectory() && tmpFile.listFiles().length <= 0) {
                        tmpFile.delete();
                    }
                }
            }
            if (dir.isDirectory() && dir.listFiles().length == 0) {
                dir.delete();
            }
        }
    }

    deleteDir = { String targetDir ->
        FileTree targetFiles = fileTree(targetDir)
        targetFiles.exclude "*.iml"
        targetFiles.each { File file ->
            file.delete()
        }
    }

    /**
     * rename api files(java, kotlin...)
     */
    renameApiFiles = { String root_dir, String suffix, String replace ->
        FileTree files = fileTree(root_dir).include("**/*$suffix")
        files.each {
            File file ->
                file.renameTo(new File(file.absolutePath.replace(suffix, replace)))
        }
    }
}